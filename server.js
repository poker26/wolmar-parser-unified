const express = require('express');
const cors = require('cors');
const { Pool } = require('pg');
const path = require('path');
const config = require('./config');
const MetalsPriceService = require('./metals-price-service');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

// Database connection
const pool = new Pool(config.dbConfig);

// Metals price service
const metalsService = new MetalsPriceService();

// Test database connection
pool.on('connect', () => {
    console.log('‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ');
});

pool.on('error', (err) => {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö:', err);
});

// API Routes

// –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∞—É–∫—Ü–∏–æ–Ω–æ–≤
app.get('/api/auctions', async (req, res) => {
    try {
        const query = `
            SELECT 
                auction_number,
                COUNT(*) as lots_count,
                MIN(auction_end_date) as start_date,
                MAX(auction_end_date) as end_date,
                SUM(winning_bid) as total_value,
                AVG(winning_bid) as avg_bid,
                MAX(winning_bid) as max_bid,
                MIN(winning_bid) as min_bid
            FROM auction_lots 
            WHERE auction_number IS NOT NULL
            GROUP BY auction_number
            ORDER BY auction_number DESC
        `;
        
        const result = await pool.query(query);
        res.json(result.rows);
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∞—É–∫—Ü–∏–æ–Ω–æ–≤:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ–± –∞—É–∫—Ü–∏–æ–Ω–∞—Ö' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å –ª–æ—Ç—ã –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∞—É–∫—Ü–∏–æ–Ω–∞
app.get('/api/auctions/:auctionNumber/lots', async (req, res) => {
    try {
        const { auctionNumber } = req.params;
        const { page = 1, limit = 20, search, metal, condition, year, minPrice, maxPrice } = req.query;
        
        let query = `
            SELECT 
                id, lot_number, coin_description, 
                avers_image_url, revers_image_url,
                winner_login, winning_bid, auction_end_date,
                bids_count, lot_status, year, letters, metal, condition, weight,
                parsed_at, source_url
            FROM auction_lots 
            WHERE auction_number = $1
        `;
        
        const queryParams = [auctionNumber];
        let paramIndex = 2;
        
        // –î–æ–±–∞–≤–ª—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã
        if (search) {
            query += ` AND coin_description ILIKE $${paramIndex}`;
            queryParams.push(`%${search}%`);
            paramIndex++;
        }
        
        if (metal) {
            query += ` AND metal = $${paramIndex}`;
            queryParams.push(metal);
            paramIndex++;
        }
        
        if (condition) {
            query += ` AND condition = $${paramIndex}`;
            queryParams.push(condition);
            paramIndex++;
        }
        
        if (year) {
            query += ` AND year = $${paramIndex}`;
            queryParams.push(parseInt(year));
            paramIndex++;
        }
        
        if (minPrice) {
            query += ` AND winning_bid >= $${paramIndex}`;
            queryParams.push(parseFloat(minPrice));
            paramIndex++;
        }
        
        if (maxPrice) {
            query += ` AND winning_bid <= $${paramIndex}`;
            queryParams.push(parseFloat(maxPrice));
            paramIndex++;
        }
        
        // –î–æ–±–∞–≤–ª—è–µ–º –ø–∞–≥–∏–Ω–∞—Ü–∏—é
        const offset = (page - 1) * limit;
        query += ` ORDER BY lot_number::int ASC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
        queryParams.push(parseInt(limit), offset);
        
        const result = await pool.query(query, queryParams);
        
        // –ü–æ–ª—É—á–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–æ—Ç–æ–≤ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
        let countQuery = `
            SELECT COUNT(*) as total
            FROM auction_lots 
            WHERE auction_number = $1
        `;
        const countParams = [auctionNumber];
        let countParamIndex = 2;
        
        if (search) {
            countQuery += ` AND coin_description ILIKE $${countParamIndex}`;
            countParams.push(`%${search}%`);
            countParamIndex++;
        }
        
        if (metal) {
            countQuery += ` AND metal = $${countParamIndex}`;
            countParams.push(metal);
            countParamIndex++;
        }
        
        if (condition) {
            countQuery += ` AND condition = $${countParamIndex}`;
            countParams.push(condition);
            countParamIndex++;
        }
        
        if (year) {
            countQuery += ` AND year = $${countParamIndex}`;
            countParams.push(parseInt(year));
            countParamIndex++;
        }
        
        if (minPrice) {
            countQuery += ` AND winning_bid >= $${countParamIndex}`;
            countParams.push(parseFloat(minPrice));
            countParamIndex++;
        }
        
        if (maxPrice) {
            countQuery += ` AND winning_bid <= $${countParamIndex}`;
            countParams.push(parseFloat(maxPrice));
            countParamIndex++;
        }
        
        const countResult = await pool.query(countQuery, countParams);
        const total = parseInt(countResult.rows[0].total);
        
        res.json({
            lots: result.rows,
            pagination: {
                page: parseInt(page),
                limit: parseInt(limit),
                total,
                pages: Math.ceil(total / limit)
            }
        });
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ª–æ—Ç–æ–≤:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ –ª–æ—Ç–∞—Ö' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ª–æ—Ç–µ
app.get('/api/lots/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const query = `
            SELECT 
                id, lot_number, auction_number, coin_description,
                avers_image_url, revers_image_url,
                winner_login, winning_bid, auction_end_date,
                bids_count, lot_status, year, letters, metal, condition, weight,
                parsed_at, source_url
            FROM auction_lots 
            WHERE id = $1
        `;
        
        const result = await pool.query(query, [id]);
        
        if (result.rows.length === 0) {
            return res.status(404).json({ error: '–õ–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω' });
        }
        
        res.json(result.rows[0]);
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ª–æ—Ç–∞:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ –ª–æ—Ç–µ' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∞—É–∫—Ü–∏–æ–Ω–∞
app.get('/api/auctions/:auctionNumber/stats', async (req, res) => {
    try {
        const { auctionNumber } = req.params;
        const query = `
            SELECT 
                COUNT(*) as total_lots,
                COUNT(CASE WHEN winning_bid IS NOT NULL THEN 1 END) as sold_lots,
                COUNT(CASE WHEN winning_bid IS NULL THEN 1 END) as unsold_lots,
                SUM(winning_bid) as total_revenue,
                AVG(winning_bid) as avg_price,
                MAX(winning_bid) as max_price,
                MIN(winning_bid) as min_price,
                COUNT(DISTINCT winner_login) as unique_bidders,
                COUNT(DISTINCT metal) as metals_count,
                COUNT(DISTINCT condition) as conditions_count
            FROM auction_lots 
            WHERE auction_number = $1
        `;
        
        const result = await pool.query(query, [auctionNumber]);
        res.json(result.rows[0]);
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–æ–≤
app.get('/api/filters', async (req, res) => {
    try {
        const { auctionNumber } = req.query;
        let whereClause = '';
        let params = [];
        
        if (auctionNumber) {
            whereClause = 'WHERE auction_number = $1';
            params = [auctionNumber];
        }
        
        // –ü–æ–ª—É—á–∞–µ–º –º–µ—Ç–∞–ª–ª—ã —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –ª–æ—Ç–æ–≤
        const metalsQuery = `
            SELECT metal, COUNT(*) as count
            FROM auction_lots 
            ${whereClause ? whereClause + ' AND' : 'WHERE'} metal IS NOT NULL AND metal != ''
            GROUP BY metal 
            ORDER BY count DESC
        `;
        
        // –ü–æ–ª—É—á–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –ª–æ—Ç–æ–≤
        const conditionsQuery = `
            SELECT condition, COUNT(*) as count
            FROM auction_lots 
            ${whereClause ? whereClause + ' AND' : 'WHERE'} condition IS NOT NULL AND condition != ''
            GROUP BY condition 
            ORDER BY count DESC
        `;
        
        // –ü–æ–ª—É—á–∞–µ–º –≥–æ–¥—ã —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –ª–æ—Ç–æ–≤
        const yearsQuery = `
            SELECT year, COUNT(*) as count
            FROM auction_lots 
            ${whereClause ? whereClause + ' AND' : 'WHERE'} year IS NOT NULL AND year > 0
            GROUP BY year 
            ORDER BY year DESC
        `;
        
        const [metalsResult, conditionsResult, yearsResult] = await Promise.all([
            pool.query(metalsQuery, params),
            pool.query(conditionsQuery, params),
            pool.query(yearsQuery, params)
        ]);
        
        res.json({
            metals: metalsResult.rows,
            conditions: conditionsResult.rows,
            years: yearsResult.rows
        });
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
app.get('/api/winners/:login', async (req, res) => {
    try {
        const { login } = req.params;
        
        // –ü–æ–ª—É—á–∞–µ–º –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
        const statsQuery = `
            SELECT 
                winner_login,
                COUNT(*) as total_lots,
                SUM(winning_bid) as total_amount,
                MIN(auction_end_date) as first_win,
                MAX(auction_end_date) as last_win
            FROM auction_lots 
            WHERE winner_login = $1
            GROUP BY winner_login
        `;
        
        const statsResult = await pool.query(statsQuery, [login]);
        
        if (statsResult.rows.length === 0) {
            return res.status(404).json({ error: '–ü–æ–±–µ–¥–∏—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' });
        }
        
        // –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∞—É–∫—Ü–∏–æ–Ω–æ–≤ –≥–¥–µ —É—á–∞—Å—Ç–≤–æ–≤–∞–ª –ø–æ–±–µ–¥–∏—Ç–µ–ª—å
        const auctionsQuery = `
            SELECT 
                auction_number,
                COUNT(*) as lots_won,
                SUM(winning_bid) as total_spent,
                MIN(auction_end_date) as auction_date
            FROM auction_lots 
            WHERE winner_login = $1
            GROUP BY auction_number
            ORDER BY auction_date DESC
        `;
        
        const auctionsResult = await pool.query(auctionsQuery, [login]);
        
        // –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫ –≤—ã–∏–≥—Ä–∞–Ω–Ω—ã—Ö –ª–æ—Ç–æ–≤
        const lotsQuery = `
            SELECT 
                id, lot_number, coin_description, 
                avers_image_url, revers_image_url,
                winning_bid, auction_end_date, auction_number,
                year, letters, metal, condition, weight
            FROM auction_lots 
            WHERE winner_login = $1
            ORDER BY auction_end_date DESC, lot_number::int ASC
        `;
        
        const lotsResult = await pool.query(lotsQuery, [login]);
        
        res.json({
            stats: statsResult.rows[0],
            auctions: auctionsResult.rows,
            lots: lotsResult.rows
        });
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
app.get('/api/statistics', async (req, res) => {
    try {
        const query = `
            SELECT 
                COUNT(DISTINCT auction_number) as total_auctions,
                COUNT(*) as total_lots,
                COUNT(CASE WHEN winning_bid IS NOT NULL THEN 1 END) as sold_lots,
                COUNT(CASE WHEN winning_bid IS NULL THEN 1 END) as unsold_lots,
                SUM(winning_bid) as total_value,
                AVG(winning_bid) as avg_price,
                MAX(winning_bid) as max_price,
                MIN(winning_bid) as min_price,
                COUNT(DISTINCT winner_login) as unique_participants,
                COUNT(DISTINCT metal) as metals_count,
                COUNT(DISTINCT condition) as conditions_count
            FROM auction_lots 
            WHERE auction_number IS NOT NULL
        `;
        
        const result = await pool.query(query);
        res.json(result.rows[0]);
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏' });
    }
});

// –ì–ª–æ–±–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ –ª–æ—Ç–æ–≤ –ø–æ –≤—Å–µ–º –∞—É–∫—Ü–∏–æ–Ω–∞–º
app.get('/api/search-lots', async (req, res) => {
    try {
        const { page = 1, limit = 20, search, metal, condition, year, minPrice, maxPrice } = req.query;
        
        let query = `
            SELECT 
                id, lot_number, coin_description, 
                avers_image_url, revers_image_url,
                winner_login, winning_bid, auction_end_date,
                bids_count, lot_status, year, letters, metal, condition, weight,
                parsed_at, source_url, auction_number
            FROM auction_lots 
            WHERE auction_number IS NOT NULL
        `;
        
        const queryParams = [];
        let paramIndex = 1;
        
        // –î–æ–±–∞–≤–ª—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã
        if (search) {
            query += ` AND coin_description ILIKE $${paramIndex}`;
            queryParams.push(`%${search}%`);
            paramIndex++;
        }
        
        if (metal) {
            query += ` AND metal = $${paramIndex}`;
            queryParams.push(metal);
            paramIndex++;
        }
        
        if (condition) {
            query += ` AND condition = $${paramIndex}`;
            queryParams.push(condition);
            paramIndex++;
        }
        
        if (year) {
            query += ` AND year = $${paramIndex}`;
            queryParams.push(parseInt(year));
            paramIndex++;
        }
        
        if (minPrice) {
            query += ` AND winning_bid >= $${paramIndex}`;
            queryParams.push(parseFloat(minPrice));
            paramIndex++;
        }
        
        if (maxPrice) {
            query += ` AND winning_bid <= $${paramIndex}`;
            queryParams.push(parseFloat(maxPrice));
            paramIndex++;
        }
        
        // –î–æ–±–∞–≤–ª—è–µ–º —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫—É –∏ –ø–∞–≥–∏–Ω–∞—Ü–∏—é
        query += ` ORDER BY winning_bid DESC NULLS LAST, auction_number DESC, lot_number ASC`;
        
        const offset = (page - 1) * limit;
        query += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
        queryParams.push(parseInt(limit), offset);
        
        const result = await pool.query(query, queryParams);
        
        // –ü–æ–ª—É—á–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
        let countQuery = `
            SELECT COUNT(*) as total
            FROM auction_lots 
            WHERE auction_number IS NOT NULL
        `;
        
        const countParams = [];
        let countParamIndex = 1;
        
        if (search) {
            countQuery += ` AND coin_description ILIKE $${countParamIndex}`;
            countParams.push(`%${search}%`);
            countParamIndex++;
        }
        
        if (metal) {
            countQuery += ` AND metal = $${countParamIndex}`;
            countParams.push(metal);
            countParamIndex++;
        }
        
        if (condition) {
            countQuery += ` AND condition = $${countParamIndex}`;
            countParams.push(condition);
            countParamIndex++;
        }
        
        if (year) {
            countQuery += ` AND year = $${countParamIndex}`;
            countParams.push(parseInt(year));
            countParamIndex++;
        }
        
        if (minPrice) {
            countQuery += ` AND winning_bid >= $${countParamIndex}`;
            countParams.push(parseFloat(minPrice));
            countParamIndex++;
        }
        
        if (maxPrice) {
            countQuery += ` AND winning_bid <= $${countParamIndex}`;
            countParams.push(parseFloat(maxPrice));
            countParamIndex++;
        }
        
        const countResult = await pool.query(countQuery, countParams);
        const total = parseInt(countResult.rows[0].total);
        
        res.json({
            lots: result.rows,
            pagination: {
                page: parseInt(page),
                limit: parseInt(limit),
                total: total,
                pages: Math.ceil(total / limit)
            }
        });
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –ª–æ—Ç–æ–≤:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –ª–æ—Ç–æ–≤' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π (–¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)
app.get('/api/winners', async (req, res) => {
    try {
        const query = `
            SELECT 
                winner_login,
                COUNT(*) as total_lots,
                SUM(winning_bid) as total_amount
            FROM auction_lots 
            WHERE winner_login IS NOT NULL AND winner_login != ''
            GROUP BY winner_login
            ORDER BY total_lots DESC
            LIMIT 20
        `;
        
        const result = await pool.query(query);
        res.json(result.rows);
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å —Ç–æ–ø –ª–æ—Ç–æ–≤ –ø–æ —Ü–µ–Ω–µ
app.get('/api/top-lots', async (req, res) => {
    try {
        const { limit = 10, auctionNumber } = req.query;
        
        let query = `
            SELECT 
                id, lot_number, auction_number, coin_description,
                avers_image_url, winning_bid, winner_login,
                auction_end_date, metal, condition, weight
            FROM auction_lots 
            WHERE winning_bid IS NOT NULL
        `;
        
        const params = [];
        let paramIndex = 1;
        
        if (auctionNumber) {
            query += ` AND auction_number = $${paramIndex}`;
            params.push(auctionNumber);
            paramIndex++;
        }
        
        query += ` ORDER BY winning_bid DESC LIMIT $${paramIndex}`;
        params.push(parseInt(limit));
        
        const result = await pool.query(query, params);
        res.json(result.rows);
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–ø –ª–æ—Ç–æ–≤:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–ø –ª–æ—Ç–æ–≤' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–∏–π –∞—É–∫—Ü–∏–æ–Ω (–ª–æ—Ç—ã –±–µ–∑ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π)
app.get('/api/current-auction', async (req, res) => {
    try {
        const { page = 1, limit = 20 } = req.query;
        
        // –°–Ω–∞—á–∞–ª–∞ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–æ–º–µ—Ä —Ç–µ–∫—É—â–µ–≥–æ –∞—É–∫—Ü–∏–æ–Ω–∞ (–∞—É–∫—Ü–∏–æ–Ω 2130, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å, –∏–Ω–∞—á–µ –∞–∫—Ç–∏–≤–Ω—ã–π –∞—É–∫—Ü–∏–æ–Ω)
        const currentAuctionQuery = `
            SELECT 
                auction_number
            FROM auction_lots 
            WHERE auction_number = '2130'
            LIMIT 1
        `;
        
        let currentAuctionResult = await pool.query(currentAuctionQuery);
        let currentAuctionNumber = currentAuctionResult.rows.length > 0 
            ? currentAuctionResult.rows[0].auction_number 
            : null;
        
        // –ï—Å–ª–∏ –∞—É–∫—Ü–∏–æ–Ω 2130 –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—â–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π –∞—É–∫—Ü–∏–æ–Ω (–¥–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è –±–æ–ª—å—à–µ —Ç–µ–∫—É—â–µ–π)
        if (!currentAuctionNumber) {
            const activeAuctionQuery = `
                SELECT 
                    auction_number
                FROM auction_lots 
                WHERE auction_number IS NOT NULL
                AND auction_end_date > NOW()
                ORDER BY auction_number DESC
                LIMIT 1
            `;
            currentAuctionResult = await pool.query(activeAuctionQuery);
            currentAuctionNumber = currentAuctionResult.rows.length > 0 
                ? currentAuctionResult.rows[0].auction_number 
                : null;
        }
        
        // –ï—Å–ª–∏ –∞–∫—Ç–∏–≤–Ω—ã–π –∞—É–∫—Ü–∏–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω, –±–µ—Ä–µ–º —Å–∞–º—ã–π –Ω–æ–≤—ã–π –∞—É–∫—Ü–∏–æ–Ω
        if (!currentAuctionNumber) {
            const latestAuctionQuery = `
                SELECT 
                    auction_number
                FROM auction_lots 
                WHERE auction_number IS NOT NULL
                ORDER BY auction_number DESC
                LIMIT 1
            `;
            currentAuctionResult = await pool.query(latestAuctionQuery);
            currentAuctionNumber = currentAuctionResult.rows.length > 0 
                ? currentAuctionResult.rows[0].auction_number 
                : null;
        }
        
        // –ï—Å–ª–∏ —Ç–µ–∫—É—â–∏–π –∞—É–∫—Ü–∏–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        if (!currentAuctionNumber) {
            return res.json({
                currentAuctionNumber: null,
                lots: [],
                pagination: {
                    page: parseInt(page),
                    limit: parseInt(limit),
                    total: 0,
                    pages: 0
                }
            });
        }
        
        // –ü–æ–ª—É—á–∞–µ–º –ª–æ—Ç—ã —Ç–µ–∫—É—â–µ–≥–æ –∞—É–∫—Ü–∏–æ–Ω–∞ (–≤—Å–µ –ª–æ—Ç—ã –¥–ª—è –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∞—É–∫—Ü–∏–æ–Ω–∞)
        const query = `
            SELECT 
                id, lot_number, auction_number, coin_description,
                avers_image_url, revers_image_url, winner_login, 
                winning_bid, auction_end_date, bids_count, lot_status,
                year, letters, metal, condition, weight, parsed_at, source_url
            FROM auction_lots 
            WHERE auction_number = $1
            ORDER BY lot_number::int ASC
            LIMIT $2 OFFSET $3
        `;
        
        const offset = (page - 1) * limit;
        const result = await pool.query(query, [currentAuctionNumber, parseInt(limit), offset]);
        
        // –ü–æ–ª—É—á–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–æ—Ç–æ–≤ —Ç–µ–∫—É—â–µ–≥–æ –∞—É–∫—Ü–∏–æ–Ω–∞
        const countQuery = `
            SELECT COUNT(*) as total
            FROM auction_lots 
            WHERE auction_number = $1
        `;
        
        const countResult = await pool.query(countQuery, [currentAuctionNumber]);
        const total = parseInt(countResult.rows[0].total);
        
        res.json({
            currentAuctionNumber: currentAuctionNumber,
            lots: result.rows,
            pagination: {
                page: parseInt(page),
                limit: parseInt(limit),
                total,
                pages: Math.ceil(total / limit)
            }
        });
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ –∞—É–∫—Ü–∏–æ–Ω–∞:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö —Ç–µ–∫—É—â–µ–≥–æ –∞—É–∫—Ü–∏–æ–Ω–∞' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ª–æ—Ç–µ (—Ä–∞–±–æ—á–∏–π —ç–Ω–¥–ø–æ–∏–Ω—Ç)
app.get('/api/lot-details/:lotId', async (req, res) => {
    try {
        const { lotId } = req.params;
        
        const query = `
            SELECT 
                id, lot_number, auction_number, coin_description,
                avers_image_url, revers_image_url, winner_login, 
                winning_bid, auction_end_date, bids_count, lot_status,
                year, letters, metal, condition, weight, parsed_at, source_url
            FROM auction_lots 
            WHERE id = $1
        `;
        
        const result = await pool.query(query, [lotId]);
        
        if (result.rows.length === 0) {
            return res.status(404).json({ error: '–õ–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω' });
        }
        
        res.json(result.rows[0]);
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–µ—Ç–∞–ª–µ–π –ª–æ—Ç–∞:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–µ—Ç–∞–ª–µ–π –ª–æ—Ç–∞' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ª–æ—Ç–µ (–¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
app.get('/api/lots/:lotId', async (req, res) => {
    try {
        const { lotId } = req.params;
        
        const query = `
            SELECT 
                id, lot_number, auction_number, coin_description,
                avers_image_url, revers_image_url, winner_login, 
                winning_bid, auction_end_date, bids_count, lot_status,
                year, letters, metal, condition, weight, parsed_at, source_url
            FROM auction_lots 
            WHERE id = $1
        `;
        
        const result = await pool.query(query, [lotId]);
        
        if (result.rows.length === 0) {
            return res.status(404).json({ error: '–õ–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω' });
        }
        
        res.json(result.rows[0]);
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–µ—Ç–∞–ª–µ–π –ª–æ—Ç–∞:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–µ—Ç–∞–ª–µ–π –ª–æ—Ç–∞' });
    }
});


// –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–≥–Ω–æ–∑—ã —Ü–µ–Ω –¥–ª—è –ª–æ—Ç–æ–≤ —Ç–µ–∫—É—â–µ–≥–æ –∞—É–∫—Ü–∏–æ–Ω–∞
app.get('/api/predictions/:auctionNumber', async (req, res) => {
    try {
        const { auctionNumber } = req.params;
        
        const query = `
            SELECT 
                al.id,
                al.lot_number,
                al.condition,
                al.metal,
                al.weight,
                al.year,
                al.letters,
                al.winning_bid,
                al.coin_description,
                lpp.predicted_price,
                lpp.metal_value,
                lpp.numismatic_premium,
                lpp.confidence_score,
                lpp.prediction_method,
                lpp.sample_size,
                lpp.created_at as prediction_created_at
            FROM auction_lots al
            LEFT JOIN lot_price_predictions lpp ON al.id = lpp.lot_id
            WHERE al.auction_number = $1
            ORDER BY al.lot_number
        `;
        
        const result = await pool.query(query, [auctionNumber]);
        
        res.json(result.rows);
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ–≥–Ω–æ–∑–æ–≤:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ–≥–Ω–æ–∑–æ–≤' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–≥–Ω–æ–∑ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ª–æ—Ç–∞
app.get('/api/prediction/:lotId', async (req, res) => {
    try {
        const { lotId } = req.params;
        
        const query = `
            SELECT 
                al.id,
                al.lot_number,
                al.condition,
                al.metal,
                al.weight,
                al.year,
                al.letters,
                al.winning_bid,
                al.coin_description,
                lpp.predicted_price,
                lpp.metal_value,
                lpp.numismatic_premium,
                lpp.confidence_score,
                lpp.prediction_method,
                lpp.sample_size,
                lpp.created_at as prediction_created_at
            FROM auction_lots al
            LEFT JOIN lot_price_predictions lpp ON al.id = lpp.lot_id
            WHERE al.id = $1
        `;
        
        const result = await pool.query(query, [lotId]);
        
        if (result.rows.length === 0) {
            return res.status(404).json({ error: '–õ–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω' });
        }
        
        res.json(result.rows[0]);
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ–≥–Ω–æ–∑–∞:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ–≥–Ω–æ–∑–∞' });
    }
});

// –ü–æ–∏—Å–∫ –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã—Ö –ª–æ—Ç–æ–≤ –¥–ª—è –∏—Å—Ç–æ—Ä–∏–∏ —Ü–µ–Ω
app.get('/api/similar-lots/:lotId', async (req, res) => {
    try {
        const { lotId } = req.params;
        
        // –°–Ω–∞—á–∞–ª–∞ –ø–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ–∫—É—â–µ–º –ª–æ—Ç–µ
        const currentLotQuery = `
            SELECT 
                coin_description, metal, condition, year, letters, auction_number
            FROM auction_lots 
            WHERE id = $1
        `;
        
        const currentLotResult = await pool.query(currentLotQuery, [lotId]);
        
        if (currentLotResult.rows.length === 0) {
            return res.status(404).json({ error: '–õ–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω' });
        }
        
        const currentLot = currentLotResult.rows[0];
        
        // –ò–∑–≤–ª–µ–∫–∞–µ–º –Ω–æ–º–∏–Ω–∞–ª –∏–∑ –æ–ø–∏—Å–∞–Ω–∏—è –º–æ–Ω–µ—Ç—ã
        const denominationMatch = currentLot.coin_description.match(/(\d+)\s*—Ä—É–±–ª–µ–π?/i);
        const currentDenomination = denominationMatch ? denominationMatch[1] : null;
        
        // –ò—â–µ–º –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–µ –ª–æ—Ç—ã —Å —É—á–µ—Ç–æ–º –Ω–æ–º–∏–Ω–∞–ª–∞
        // –¢–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –ø–æ condition, metal, year, letters –ò –Ω–æ–º–∏–Ω–∞–ª—É
        // –ò—Å–∫–ª—é—á–∞–µ–º –ª–æ—Ç—ã —Ç–µ–∫—É—â–µ–≥–æ –∞—É–∫—Ü–∏–æ–Ω–∞
        let similarQuery = `
            SELECT 
                id, lot_number, auction_number, coin_description,
                winning_bid, winner_login, auction_end_date,
                metal, condition, year, letters, weight
            FROM auction_lots 
            WHERE condition = $2 
                AND metal = $3 
                AND year = $4 
                AND letters = $5
                AND id != $1
                AND auction_number != $6
                AND winning_bid IS NOT NULL 
                AND winning_bid > 0
        `;
        
        const params = [
            lotId,
            currentLot.condition,
            currentLot.metal, 
            currentLot.year,
            currentLot.letters,
            currentLot.auction_number
        ];
        
        // –ï—Å–ª–∏ –Ω–æ–º–∏–Ω–∞–ª –Ω–∞–π–¥–µ–Ω, –¥–æ–±–∞–≤–ª—è–µ–º –µ–≥–æ –≤ —É—Å–ª–æ–≤–∏–µ –ø–æ–∏—Å–∫–∞
        if (currentDenomination) {
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ —Å–ª–æ–≤
            similarQuery += ` AND coin_description ~ $${params.length + 1}`;
            params.push(`\\m${currentDenomination}\\s*—Ä—É–±–ª–µ–π?\\M`);
        }
        
        similarQuery += ` ORDER BY auction_end_date DESC`;
        
        const similarResult = await pool.query(similarQuery, params);
        
        res.json({
            currentLot: currentLot,
            similarLots: similarResult.rows
        });
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã—Ö –ª–æ—Ç–æ–≤:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã—Ö –ª–æ—Ç–æ–≤' });
    }
});

// –≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –≤ CSV
app.get('/api/export/csv', async (req, res) => {
    try {
        const { auctionNumber } = req.query;
        
        let query = `
            SELECT 
                lot_number, auction_number, coin_description,
                winner_login, winning_bid, auction_end_date,
                bids_count, lot_status, year, letters, metal, condition,
                parsed_at, source_url
            FROM auction_lots
        `;
        
        const params = [];
        if (auctionNumber) {
            query += ` WHERE auction_number = $1`;
            params.push(auctionNumber);
        }
        
        query += ` ORDER BY auction_number DESC, lot_number::int ASC`;
        
        const result = await pool.query(query, params);
        
        // –°–æ–∑–¥–∞–µ–º CSV
        const headers = [
            '–ù–æ–º–µ—Ä –ª–æ—Ç–∞', '–ù–æ–º–µ—Ä –∞—É–∫—Ü–∏–æ–Ω–∞', '–û–ø–∏—Å–∞–Ω–∏–µ –º–æ–Ω–µ—Ç—ã',
            '–ü–æ–±–µ–¥–∏—Ç–µ–ª—å', '–¶–µ–Ω–∞', '–î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è –∞—É–∫—Ü–∏–æ–Ω–∞',
            '–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç–∞–≤–æ–∫', '–°—Ç–∞—Ç—É—Å', '–ì–æ–¥', '–ë—É–∫–≤—ã', '–ú–µ—Ç–∞–ª–ª', '–°–æ—Å—Ç–æ—è–Ω–∏–µ',
            '–î–∞—Ç–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞', 'URL –∏—Å—Ç–æ—á–Ω–∏–∫–∞'
        ];
        
        const csvContent = [
            headers.join(','),
            ...result.rows.map(row => [
                row.lot_number || '',
                row.auction_number || '',
                `"${(row.coin_description || '').replace(/"/g, '""')}"`,
                row.winner_login || '',
                row.winning_bid || '',
                row.auction_end_date || '',
                row.bids_count || '',
                row.lot_status || '',
                row.year || '',
                row.letters || '',
                row.metal || '',
                row.condition || '',
                row.parsed_at || '',
                row.source_url || ''
            ].join(','))
        ].join('\n');
        
        res.setHeader('Content-Type', 'text/csv; charset=utf-8');
        res.setHeader('Content-Disposition', `attachment; filename="wolmar-auctions${auctionNumber ? `-${auctionNumber}` : ''}-${new Date().toISOString().split('T')[0]}.csv"`);
        res.send('\ufeff' + csvContent); // BOM –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ Excel
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ CSV:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ –¥–∞–Ω–Ω—ã—Ö' });
    }
});

// Metals prices API endpoints
app.get('/api/metals-prices/:date', async (req, res) => {
    try {
        const { date } = req.params;
        const { metal = 'gold' } = req.query;
        const priceData = await metalsService.getMetalPriceFromDB(date, metal);
        
        if (!priceData) {
            return res.status(404).json({ error: '–î–∞–Ω–Ω—ã–µ –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—É—é –¥–∞—Ç—É –Ω–µ –Ω–∞–π–¥–µ–Ω—ã' });
        }
        
        res.json(priceData);
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω –Ω–∞ –º–µ—Ç–∞–ª–ª—ã:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω –Ω–∞ –º–µ—Ç–∞–ª–ª—ã' });
    }
});

app.get('/api/metals-prices', async (req, res) => {
    try {
        const { start_date, end_date, limit = 100 } = req.query;
        
        let query = `
            SELECT date, usd_rate, gold_price, silver_price, platinum_price, palladium_price
            FROM metals_prices
            WHERE 1=1
        `;
        const params = [];
        let paramIndex = 1;
        
        if (start_date) {
            query += ` AND date >= $${paramIndex}`;
            params.push(start_date);
            paramIndex++;
        }
        
        if (end_date) {
            query += ` AND date <= $${paramIndex}`;
            params.push(end_date);
            paramIndex++;
        }
        
        query += ` ORDER BY date DESC LIMIT $${paramIndex}`;
        params.push(parseInt(limit));
        
        const result = await pool.query(query, params);
        res.json(result.rows);
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ —Ü–µ–Ω –Ω–∞ –º–µ—Ç–∞–ª–ª—ã:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ —Ü–µ–Ω –Ω–∞ –º–µ—Ç–∞–ª–ª—ã' });
    }
});

app.get('/api/numismatic-premium/:lotId', async (req, res) => {
    try {
        const { lotId } = req.params;
        
        // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ª–æ—Ç–∞
        const lotQuery = `
            SELECT id, lot_number, auction_number, coin_description, 
                   winning_bid, auction_end_date, metal, weight
            FROM auction_lots 
            WHERE id = $1
        `;
        
        const lotResult = await pool.query(lotQuery, [lotId]);
        
        if (lotResult.rows.length === 0) {
            return res.status(404).json({ error: '–õ–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω' });
        }
        
        const lot = lotResult.rows[0];
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å –≤—Å–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–∞–Ω–Ω—ã–µ
        if (!lot.winning_bid || !lot.metal || !lot.weight || !lot.auction_end_date) {
            return res.status(400).json({ 
                error: '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –Ω—É–º–∏–∑–º–∞—Ç–∏—á–µ—Å–∫–æ–π –Ω–∞—Ü–µ–Ω–∫–∏',
                missing: {
                    winning_bid: !lot.winning_bid,
                    metal: !lot.metal,
                    weight: !lot.weight,
                    auction_end_date: !lot.auction_end_date
                }
            });
        }
        
        // –ü–æ–ª—É—á–∞–µ–º —Ü–µ–Ω—É –º–µ—Ç–∞–ª–ª–∞ –Ω–∞ –¥–∞—Ç—É –∞—É–∫—Ü–∏–æ–Ω–∞ (—Ç–æ–ª—å–∫–æ –¥–∞—Ç–∞, –±–µ–∑ –≤—Ä–µ–º–µ–Ω–∏)
        const metalType = lot.metal.toLowerCase() + '_price';
        const auctionDate = new Date(lot.auction_end_date).toISOString().split('T')[0]; // YYYY-MM-DD
        const priceData = await metalsService.getMetalPriceFromDB(auctionDate, metalType);
        
        if (!priceData) {
            return res.status(404).json({ 
                error: '–¶–µ–Ω–∞ –º–µ—Ç–∞–ª–ª–∞ –Ω–∞ –¥–∞—Ç—É –∞—É–∫—Ü–∏–æ–Ω–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞',
                auction_date: lot.auction_end_date
            });
        }
        
        // –í—ã—á–∏—Å–ª—è–µ–º –Ω—É–º–∏–∑–º–∞—Ç–∏—á–µ—Å–∫—É—é –Ω–∞—Ü–µ–Ω–∫—É
        const premium = metalsService.calculateNumismaticPremium(
            lot.winning_bid,
            lot.weight,
            priceData.price,
            priceData.usdRate
        );
        
        res.json({
            lot: {
                id: lot.id,
                lot_number: lot.lot_number,
                auction_number: lot.auction_number,
                metal: lot.metal,
                weight: lot.weight,
                winning_bid: lot.winning_bid,
                auction_end_date: lot.auction_end_date
            },
            metal_price: {
                price_per_gram: priceData.price,
                usd_rate: priceData.usdRate,
                date: lot.auction_end_date
            },
            numismatic_premium: premium
        });
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –Ω—É–º–∏–∑–º–∞—Ç–∏—á–µ—Å–∫–æ–π –Ω–∞—Ü–µ–Ω–∫–∏:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –Ω—É–º–∏–∑–º–∞—Ç–∏—á–µ—Å–∫–æ–π –Ω–∞—Ü–µ–Ω–∫–∏' });
    }
});

// API —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –Ω—É–º–∏–∑–º–∞—Ç–∏—á–µ—Å–∫–æ–π –Ω–∞—Ü–µ–Ω–∫–∏ –Ω–∞ —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É
app.get('/api/numismatic-premium-current/:lotId', async (req, res) => {
    try {
        const { lotId } = req.params;
        
        // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ª–æ—Ç–∞
        const lotQuery = `
            SELECT id, lot_number, auction_number, coin_description, 
                   winning_bid, auction_end_date, metal, weight
            FROM auction_lots 
            WHERE id = $1
        `;
        
        const lotResult = await pool.query(lotQuery, [lotId]);
        
        if (lotResult.rows.length === 0) {
            return res.status(404).json({ error: '–õ–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω' });
        }
        
        const lot = lotResult.rows[0];
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å –≤—Å–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–∞–Ω–Ω—ã–µ
        if (!lot.winning_bid || !lot.metal || !lot.weight) {
            return res.status(400).json({ 
                error: '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –Ω—É–º–∏–∑–º–∞—Ç–∏—á–µ—Å–∫–æ–π –Ω–∞—Ü–µ–Ω–∫–∏',
                missing: {
                    winning_bid: !lot.winning_bid,
                    metal: !lot.metal,
                    weight: !lot.weight
                }
            });
        }
        
        // –ü–æ–ª—É—á–∞–µ–º —Ü–µ–Ω—É –º–µ—Ç–∞–ª–ª–∞ –Ω–∞ —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É (—Å–µ–≥–æ–¥–Ω—è –∏–ª–∏ –≤—á–µ—Ä–∞)
        const metalType = lot.metal.toLowerCase() + '_price';
        const today = new Date().toISOString().split('T')[0];
        const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString().split('T')[0];
        
        let priceData = await metalsService.getMetalPriceFromDB(today, metalType);
        let priceDate = today;
        
        // –ï—Å–ª–∏ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –Ω–∞ —Å–µ–≥–æ–¥–Ω—è, –ø—Ä–æ–±—É–µ–º –≤—á–µ—Ä–∞
        if (!priceData) {
            priceData = await metalsService.getMetalPriceFromDB(yesterday, metalType);
            priceDate = yesterday;
        }
        
        if (!priceData) {
            return res.status(404).json({ 
                error: '–¶–µ–Ω–∞ –º–µ—Ç–∞–ª–ª–∞ –Ω–∞ —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É –Ω–µ –Ω–∞–π–¥–µ–Ω–∞',
                tried_dates: [today, yesterday]
            });
        }
        
        // –í—ã—á–∏—Å–ª—è–µ–º –Ω—É–º–∏–∑–º–∞—Ç–∏—á–µ—Å–∫—É—é –Ω–∞—Ü–µ–Ω–∫—É
        const premium = metalsService.calculateNumismaticPremium(
            lot.winning_bid,
            lot.weight,
            priceData.price,
            priceData.usdRate
        );
        
        res.json({
            lot: {
                id: lot.id,
                lot_number: lot.lot_number,
                auction_number: lot.auction_number,
                metal: lot.metal,
                weight: lot.weight,
                winning_bid: lot.winning_bid,
                auction_end_date: lot.auction_end_date
            },
            metal_price: {
                price_per_gram: priceData.price,
                usd_rate: priceData.usdRate,
                date: priceDate
            },
            numismatic_premium: premium
        });
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –Ω—É–º–∏–∑–º–∞—Ç–∏—á–µ—Å–∫–æ–π –Ω–∞—Ü–µ–Ω–∫–∏ –Ω–∞ —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –Ω—É–º–∏–∑–º–∞—Ç–∏—á–µ—Å–∫–æ–π –Ω–∞—Ü–µ–Ω–∫–∏ –Ω–∞ —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É' });
    }
});

// Serve React app
app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Error handling middleware
app.use((error, req, res, next) => {
    console.error('–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞:', error);
    res.status(500).json({ error: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
});

// Start server
app.listen(PORT, () => {
    console.log(`üöÄ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}`);
    console.log(`üìä API –¥–æ—Å—Ç—É–ø–Ω–æ –ø–æ –∞–¥—Ä–µ—Å—É: http://localhost:${PORT}/api`);
    console.log(`üåê –í–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å: http://localhost:${PORT}`);
});

// –≠–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Å–µ—Ö –ª–æ—Ç–æ–≤ —Ç–µ–∫—É—â–µ–≥–æ –∞—É–∫—Ü–∏–æ–Ω–∞ (–¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏)
app.get('/api/current-auction-all', async (req, res) => {
    try {
        // –°–Ω–∞—á–∞–ª–∞ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–æ–º–µ—Ä —Ç–µ–∫—É—â–µ–≥–æ –∞—É–∫—Ü–∏–æ–Ω–∞ (–∞—É–∫—Ü–∏–æ–Ω 2130, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å, –∏–Ω–∞—á–µ –∞–∫—Ç–∏–≤–Ω—ã–π –∞—É–∫—Ü–∏–æ–Ω)
        const currentAuctionQuery = `
            SELECT 
                auction_number
            FROM auction_lots 
            WHERE auction_number = '2130'
            LIMIT 1
        `;
        
        let currentAuctionResult = await pool.query(currentAuctionQuery);
        let currentAuctionNumber = currentAuctionResult.rows.length > 0 
            ? currentAuctionResult.rows[0].auction_number 
            : null;
        
        // –ï—Å–ª–∏ –∞—É–∫—Ü–∏–æ–Ω 2130 –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—â–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π –∞—É–∫—Ü–∏–æ–Ω (–¥–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è –±–æ–ª—å—à–µ —Ç–µ–∫—É—â–µ–π)
        if (!currentAuctionNumber) {
            const activeAuctionQuery = `
                SELECT 
                    auction_number
                FROM auction_lots 
                WHERE auction_number IS NOT NULL
                AND auction_end_date > NOW()
                ORDER BY auction_number DESC
                LIMIT 1
            `;
            currentAuctionResult = await pool.query(activeAuctionQuery);
            currentAuctionNumber = currentAuctionResult.rows.length > 0 
                ? currentAuctionResult.rows[0].auction_number 
                : null;
        }
        
        // –ï—Å–ª–∏ –∞–∫—Ç–∏–≤–Ω—ã–π –∞—É–∫—Ü–∏–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω, –±–µ—Ä–µ–º —Å–∞–º—ã–π –Ω–æ–≤—ã–π –∞—É–∫—Ü–∏–æ–Ω
        if (!currentAuctionNumber) {
            const latestAuctionQuery = `
                SELECT 
                    auction_number
                FROM auction_lots 
                WHERE auction_number IS NOT NULL
                ORDER BY auction_number DESC
                LIMIT 1
            `;
            currentAuctionResult = await pool.query(latestAuctionQuery);
            currentAuctionNumber = currentAuctionResult.rows.length > 0 
                ? currentAuctionResult.rows[0].auction_number 
                : null;
        }
        
        // –ï—Å–ª–∏ —Ç–µ–∫—É—â–∏–π –∞—É–∫—Ü–∏–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        if (!currentAuctionNumber) {
            return res.json({
                currentAuctionNumber: null,
                lots: [],
                total: 0
            });
        }
        
        // –ü–æ–ª—É—á–∞–µ–º –í–°–ï –ª–æ—Ç—ã —Ç–µ–∫—É—â–µ–≥–æ –∞—É–∫—Ü–∏–æ–Ω–∞ (–±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π)
        const query = `
            SELECT 
                id, lot_number, auction_number, coin_description,
                avers_image_url, revers_image_url, winner_login, 
                winning_bid, auction_end_date, bids_count, lot_status,
                year, letters, metal, condition, weight, parsed_at, source_url
            FROM auction_lots 
            WHERE auction_number = $1
            ORDER BY lot_number::int ASC
        `;
        
        const result = await pool.query(query, [currentAuctionNumber]);
        
        res.json({
            currentAuctionNumber: currentAuctionNumber,
            lots: result.rows,
            total: result.rows.length
        });
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Å–µ—Ö –ª–æ—Ç–æ–≤ —Ç–µ–∫—É—â–µ–≥–æ –∞—É–∫—Ü–∏–æ–Ω–∞:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ª–æ—Ç–æ–≤' });
    }
});

// Graceful shutdown
process.on('SIGINT', async () => {
    console.log('\nüõë –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è, –∑–∞–∫—Ä—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è...');
    await pool.end();
    process.exit(0);
});

module.exports = app;
