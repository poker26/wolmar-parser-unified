const express = require('express');
const cors = require('cors');
const { Pool } = require('pg');
const path = require('path');
const config = require('./config');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

// Database connection
const pool = new Pool(config.dbConfig);

// Test database connection
pool.on('connect', () => {
    console.log('‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ');
});

pool.on('error', (err) => {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö:', err);
});

// API Routes

// –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∞—É–∫—Ü–∏–æ–Ω–æ–≤
app.get('/api/auctions', async (req, res) => {
    try {
        const query = `
            SELECT 
                auction_number,
                COUNT(*) as lots_count,
                MIN(auction_end_date) as start_date,
                MAX(auction_end_date) as end_date,
                SUM(winning_bid) as total_value,
                AVG(winning_bid) as avg_bid,
                MAX(winning_bid) as max_bid,
                MIN(winning_bid) as min_bid
            FROM auction_lots 
            WHERE auction_number IS NOT NULL
            GROUP BY auction_number
            ORDER BY auction_number DESC
        `;
        
        const result = await pool.query(query);
        res.json(result.rows);
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∞—É–∫—Ü–∏–æ–Ω–æ–≤:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ–± –∞—É–∫—Ü–∏–æ–Ω–∞—Ö' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å –ª–æ—Ç—ã –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∞—É–∫—Ü–∏–æ–Ω–∞
app.get('/api/auctions/:auctionNumber/lots', async (req, res) => {
    try {
        const { auctionNumber } = req.params;
        const { page = 1, limit = 20, search, metal, condition, year, minPrice, maxPrice } = req.query;
        
        let query = `
            SELECT 
                id, lot_number, coin_description, 
                avers_image_url, revers_image_url,
                winner_login, winning_bid, auction_end_date,
                bids_count, lot_status, year, letters, metal, condition,
                parsed_at, source_url
            FROM auction_lots 
            WHERE auction_number = $1
        `;
        
        const queryParams = [auctionNumber];
        let paramIndex = 2;
        
        // –î–æ–±–∞–≤–ª—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã
        if (search) {
            query += ` AND coin_description ILIKE $${paramIndex}`;
            queryParams.push(`%${search}%`);
            paramIndex++;
        }
        
        if (metal) {
            query += ` AND metal = $${paramIndex}`;
            queryParams.push(metal);
            paramIndex++;
        }
        
        if (condition) {
            query += ` AND condition = $${paramIndex}`;
            queryParams.push(condition);
            paramIndex++;
        }
        
        if (year) {
            query += ` AND year = $${paramIndex}`;
            queryParams.push(parseInt(year));
            paramIndex++;
        }
        
        if (minPrice) {
            query += ` AND winning_bid >= $${paramIndex}`;
            queryParams.push(parseFloat(minPrice));
            paramIndex++;
        }
        
        if (maxPrice) {
            query += ` AND winning_bid <= $${paramIndex}`;
            queryParams.push(parseFloat(maxPrice));
            paramIndex++;
        }
        
        // –î–æ–±–∞–≤–ª—è–µ–º –ø–∞–≥–∏–Ω–∞—Ü–∏—é
        const offset = (page - 1) * limit;
        query += ` ORDER BY lot_number::int ASC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
        queryParams.push(parseInt(limit), offset);
        
        const result = await pool.query(query, queryParams);
        
        // –ü–æ–ª—É—á–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–æ—Ç–æ–≤ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
        let countQuery = `
            SELECT COUNT(*) as total
            FROM auction_lots 
            WHERE auction_number = $1
        `;
        const countParams = [auctionNumber];
        let countParamIndex = 2;
        
        if (search) {
            countQuery += ` AND coin_description ILIKE $${countParamIndex}`;
            countParams.push(`%${search}%`);
            countParamIndex++;
        }
        
        if (metal) {
            countQuery += ` AND metal = $${countParamIndex}`;
            countParams.push(metal);
            countParamIndex++;
        }
        
        if (condition) {
            countQuery += ` AND condition = $${countParamIndex}`;
            countParams.push(condition);
            countParamIndex++;
        }
        
        if (year) {
            countQuery += ` AND year = $${countParamIndex}`;
            countParams.push(parseInt(year));
            countParamIndex++;
        }
        
        if (minPrice) {
            countQuery += ` AND winning_bid >= $${countParamIndex}`;
            countParams.push(parseFloat(minPrice));
            countParamIndex++;
        }
        
        if (maxPrice) {
            countQuery += ` AND winning_bid <= $${countParamIndex}`;
            countParams.push(parseFloat(maxPrice));
            countParamIndex++;
        }
        
        const countResult = await pool.query(countQuery, countParams);
        const total = parseInt(countResult.rows[0].total);
        
        res.json({
            lots: result.rows,
            pagination: {
                page: parseInt(page),
                limit: parseInt(limit),
                total,
                pages: Math.ceil(total / limit)
            }
        });
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ª–æ—Ç–æ–≤:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ –ª–æ—Ç–∞—Ö' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ª–æ—Ç–µ
app.get('/api/lots/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const query = `
            SELECT 
                id, lot_number, auction_number, coin_description,
                avers_image_url, revers_image_url,
                winner_login, winning_bid, auction_end_date,
                bids_count, lot_status, year, letters, metal, condition,
                parsed_at, source_url
            FROM auction_lots 
            WHERE id = $1
        `;
        
        const result = await pool.query(query, [id]);
        
        if (result.rows.length === 0) {
            return res.status(404).json({ error: '–õ–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω' });
        }
        
        res.json(result.rows[0]);
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ª–æ—Ç–∞:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ –ª–æ—Ç–µ' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∞—É–∫—Ü–∏–æ–Ω–∞
app.get('/api/auctions/:auctionNumber/stats', async (req, res) => {
    try {
        const { auctionNumber } = req.params;
        const query = `
            SELECT 
                COUNT(*) as total_lots,
                COUNT(CASE WHEN winning_bid IS NOT NULL THEN 1 END) as sold_lots,
                COUNT(CASE WHEN winning_bid IS NULL THEN 1 END) as unsold_lots,
                SUM(winning_bid) as total_revenue,
                AVG(winning_bid) as avg_price,
                MAX(winning_bid) as max_price,
                MIN(winning_bid) as min_price,
                COUNT(DISTINCT winner_login) as unique_bidders,
                COUNT(DISTINCT metal) as metals_count,
                COUNT(DISTINCT condition) as conditions_count
            FROM auction_lots 
            WHERE auction_number = $1
        `;
        
        const result = await pool.query(query, [auctionNumber]);
        res.json(result.rows[0]);
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–æ–≤
app.get('/api/filters', async (req, res) => {
    try {
        const { auctionNumber } = req.query;
        let whereClause = '';
        let params = [];
        
        if (auctionNumber) {
            whereClause = 'WHERE auction_number = $1';
            params = [auctionNumber];
        }
        
        // –ü–æ–ª—É—á–∞–µ–º –º–µ—Ç–∞–ª–ª—ã —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –ª–æ—Ç–æ–≤
        const metalsQuery = `
            SELECT metal, COUNT(*) as count
            FROM auction_lots 
            ${whereClause ? whereClause + ' AND' : 'WHERE'} metal IS NOT NULL AND metal != ''
            GROUP BY metal 
            ORDER BY count DESC
        `;
        
        // –ü–æ–ª—É—á–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –ª–æ—Ç–æ–≤
        const conditionsQuery = `
            SELECT condition, COUNT(*) as count
            FROM auction_lots 
            ${whereClause ? whereClause + ' AND' : 'WHERE'} condition IS NOT NULL AND condition != ''
            GROUP BY condition 
            ORDER BY count DESC
        `;
        
        // –ü–æ–ª—É—á–∞–µ–º –≥–æ–¥—ã —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –ª–æ—Ç–æ–≤
        const yearsQuery = `
            SELECT year, COUNT(*) as count
            FROM auction_lots 
            ${whereClause ? whereClause + ' AND' : 'WHERE'} year IS NOT NULL AND year > 0
            GROUP BY year 
            ORDER BY year DESC
        `;
        
        const [metalsResult, conditionsResult, yearsResult] = await Promise.all([
            pool.query(metalsQuery, params),
            pool.query(conditionsQuery, params),
            pool.query(yearsQuery, params)
        ]);
        
        res.json({
            metals: metalsResult.rows,
            conditions: conditionsResult.rows,
            years: yearsResult.rows
        });
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
app.get('/api/winners/:login', async (req, res) => {
    try {
        const { login } = req.params;
        
        // –ü–æ–ª—É—á–∞–µ–º –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
        const statsQuery = `
            SELECT 
                winner_login,
                COUNT(*) as total_lots,
                SUM(winning_bid) as total_amount,
                MIN(auction_end_date) as first_win,
                MAX(auction_end_date) as last_win
            FROM auction_lots 
            WHERE winner_login = $1
            GROUP BY winner_login
        `;
        
        const statsResult = await pool.query(statsQuery, [login]);
        
        if (statsResult.rows.length === 0) {
            return res.status(404).json({ error: '–ü–æ–±–µ–¥–∏—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' });
        }
        
        // –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∞—É–∫—Ü–∏–æ–Ω–æ–≤ –≥–¥–µ —É—á–∞—Å—Ç–≤–æ–≤–∞–ª –ø–æ–±–µ–¥–∏—Ç–µ–ª—å
        const auctionsQuery = `
            SELECT 
                auction_number,
                COUNT(*) as lots_won,
                SUM(winning_bid) as total_spent,
                MIN(auction_end_date) as auction_date
            FROM auction_lots 
            WHERE winner_login = $1
            GROUP BY auction_number
            ORDER BY auction_date DESC
        `;
        
        const auctionsResult = await pool.query(auctionsQuery, [login]);
        
        // –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫ –≤—ã–∏–≥—Ä–∞–Ω–Ω—ã—Ö –ª–æ—Ç–æ–≤
        const lotsQuery = `
            SELECT 
                id, lot_number, coin_description, 
                avers_image_url, revers_image_url,
                winning_bid, auction_end_date, auction_number,
                year, letters, metal, condition
            FROM auction_lots 
            WHERE winner_login = $1
            ORDER BY auction_end_date DESC, lot_number::int ASC
        `;
        
        const lotsResult = await pool.query(lotsQuery, [login]);
        
        res.json({
            stats: statsResult.rows[0],
            auctions: auctionsResult.rows,
            lots: lotsResult.rows
        });
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π (–¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)
app.get('/api/winners', async (req, res) => {
    try {
        const query = `
            SELECT 
                winner_login,
                COUNT(*) as total_lots,
                SUM(winning_bid) as total_amount
            FROM auction_lots 
            WHERE winner_login IS NOT NULL AND winner_login != ''
            GROUP BY winner_login
            ORDER BY total_lots DESC
            LIMIT 20
        `;
        
        const result = await pool.query(query);
        res.json(result.rows);
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å —Ç–æ–ø –ª–æ—Ç–æ–≤ –ø–æ —Ü–µ–Ω–µ
app.get('/api/top-lots', async (req, res) => {
    try {
        const { limit = 10, auctionNumber } = req.query;
        
        let query = `
            SELECT 
                id, lot_number, auction_number, coin_description,
                avers_image_url, winning_bid, winner_login,
                auction_end_date, metal, condition
            FROM auction_lots 
            WHERE winning_bid IS NOT NULL
        `;
        
        const params = [];
        let paramIndex = 1;
        
        if (auctionNumber) {
            query += ` AND auction_number = $${paramIndex}`;
            params.push(auctionNumber);
            paramIndex++;
        }
        
        query += ` ORDER BY winning_bid DESC LIMIT $${paramIndex}`;
        params.push(parseInt(limit));
        
        const result = await pool.query(query, params);
        res.json(result.rows);
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–ø –ª–æ—Ç–æ–≤:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–ø –ª–æ—Ç–æ–≤' });
    }
});

// –≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –≤ CSV
app.get('/api/export/csv', async (req, res) => {
    try {
        const { auctionNumber } = req.query;
        
        let query = `
            SELECT 
                lot_number, auction_number, coin_description,
                winner_login, winning_bid, auction_end_date,
                bids_count, lot_status, year, letters, metal, condition,
                parsed_at, source_url
            FROM auction_lots
        `;
        
        const params = [];
        if (auctionNumber) {
            query += ` WHERE auction_number = $1`;
            params.push(auctionNumber);
        }
        
        query += ` ORDER BY auction_number DESC, lot_number::int ASC`;
        
        const result = await pool.query(query, params);
        
        // –°–æ–∑–¥–∞–µ–º CSV
        const headers = [
            '–ù–æ–º–µ—Ä –ª–æ—Ç–∞', '–ù–æ–º–µ—Ä –∞—É–∫—Ü–∏–æ–Ω–∞', '–û–ø–∏—Å–∞–Ω–∏–µ –º–æ–Ω–µ—Ç—ã',
            '–ü–æ–±–µ–¥–∏—Ç–µ–ª—å', '–¶–µ–Ω–∞', '–î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è –∞—É–∫—Ü–∏–æ–Ω–∞',
            '–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç–∞–≤–æ–∫', '–°—Ç–∞—Ç—É—Å', '–ì–æ–¥', '–ë—É–∫–≤—ã', '–ú–µ—Ç–∞–ª–ª', '–°–æ—Å—Ç–æ—è–Ω–∏–µ',
            '–î–∞—Ç–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞', 'URL –∏—Å—Ç–æ—á–Ω–∏–∫–∞'
        ];
        
        const csvContent = [
            headers.join(','),
            ...result.rows.map(row => [
                row.lot_number || '',
                row.auction_number || '',
                `"${(row.coin_description || '').replace(/"/g, '""')}"`,
                row.winner_login || '',
                row.winning_bid || '',
                row.auction_end_date || '',
                row.bids_count || '',
                row.lot_status || '',
                row.year || '',
                row.letters || '',
                row.metal || '',
                row.condition || '',
                row.parsed_at || '',
                row.source_url || ''
            ].join(','))
        ].join('\n');
        
        res.setHeader('Content-Type', 'text/csv; charset=utf-8');
        res.setHeader('Content-Disposition', `attachment; filename="wolmar-auctions${auctionNumber ? `-${auctionNumber}` : ''}-${new Date().toISOString().split('T')[0]}.csv"`);
        res.send('\ufeff' + csvContent); // BOM –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ Excel
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ CSV:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ –¥–∞–Ω–Ω—ã—Ö' });
    }
});

// Serve React app
app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Error handling middleware
app.use((error, req, res, next) => {
    console.error('–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞:', error);
    res.status(500).json({ error: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
});

// Start server
app.listen(PORT, () => {
    console.log(`üöÄ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}`);
    console.log(`üìä API –¥–æ—Å—Ç—É–ø–Ω–æ –ø–æ –∞–¥—Ä–µ—Å—É: http://localhost:${PORT}/api`);
    console.log(`üåê –í–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å: http://localhost:${PORT}`);
});

// Graceful shutdown
process.on('SIGINT', async () => {
    console.log('\nüõë –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è, –∑–∞–∫—Ä—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è...');
    await pool.end();
    process.exit(0);
});

module.exports = app;
